不同 GC 和堆内存的总结

堆内存：
jvm堆内存分为堆和非堆

堆：
堆分为年轻代和老年代，年轻代里面有eden区和from区和to区
通过-xmx分配堆的最大大小，-xms分配堆的初始大小，这两个大小最好保持一致，因为如果一开始初始大小很小，然后就需要扩容，扩容的流程是重新申请新内存，将现在的内存复制到新内存，释放原有的内存，代价比较昂贵。
通过-xmn分配年轻代的大小，-xx:SurvivorRatio=8 分配eden区占有年轻代的比例，如果是8，代表着eden:from:to = 8:1:1

非堆：
非堆里包括元空间，类信息和编译代码信息
元空间包括常量池
通过 -XX:MaxMetaspaceSize=size配置最大meta区, Java8 默认不限制 Meta 空间，一般不允许设置该选项

堆外内存：
就是在jvm管理以外的内存，不属于jvm的堆
通过 -XX:MaxDirectMemorySize=size配置，系统可以使用的最大堆外内存  


GC
串行gc：
-XX:+UseSerialGC
用一个线程去执行gc，并且不能执行业务线程，所以stw最长

并行gc：
-XX:+UseParallelGC
用多个线程并行的执行gc，这段时间也需要stw，但吞吐量是最高的，如果要追求吞吐量，而不在意较长的stw，可以选择并行gc，也是1.8默认的gc

cms：
-XX:+UseConcMarkSweepGC  
cms是回收老年代的gc，一般结合ParNew（回收年轻代）来使用，吞吐量比并行gc低，stw比并行gc短
cms收集过程分六步：
1.初始标记，标记root
2.并发标记
3.并发预清理
4.最终标记
5.并发清除
6.并发重置
root包括：gc root，gc root的直接引用的对象，跨代引用的对象
gc root包括：虚拟机栈中的局部变量表引用的对象，本地方法栈引用的对象，方法区中的常量，方法区中的静态变量


g1：
-XX:+UseG1GC
g1垃圾收集器是分region的，每个区都有卡表和记忆集，占到百分之20的空间，所以g1收集器适合大内存（6g以上），可以尽可能的控制stw的时常，通过配置-XX:MaxGCPauseMillis=n，如果一旦出现清理不过来的情况，会退化成串行gc
g1收集过程：
1.初始标记
2.Root区扫描
3.并发标记
4.再次标记
5.清理